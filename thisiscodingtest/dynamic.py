'''
2021.10.28
[이것이 코딩테스트다] p.217 1로 만들기
정수 X가 주어질 때 정수 X에 사용할 수 있는 연산은 다음과 같다
a. X가 5로 나누어떨어지면, 5로 나눈다.
b. X가 3로 나누어떨어지면, 3로 나눈다.
c. X가 2로 나누어떨어지면, 5로 나눈다.
d. X에서 1을 뺀다.
연산 4개를 적절히 이용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.
<입력예시> <출력 예시>
26       3
'''
# 나의 답
n = 26
r = 0

while True:
    if n == 0:
        break
    if n & 5 == 0:
        n = n // 5
        r += 1
        print('--1', n, r)
    elif n & 3 == 0:
        n = n // 3
        r += 1
        print('--2', n, r)
    elif n & 2 == 0:
        n = n // 2
        r += 1
        print('--3', n, r)
    else:
        n = n - 1
        r += 1
        print('--4', n, r)
        
print(r)

# 해설
x = int(input())

# 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화
d = [0] * 30001

# 다이나믹 프로그래밍 진행(보텀업)
for i in range(2,  x+1):
    # 현재의 수에서 1을빼는 경우
    d[i] = d[i - 1] + 1
    # 현재의 수가 2로 나누어 떨어지는 경우
    if i % 2 == 0:
        d[i] = min(d[i], d[i//2]+1)
    # 현재의 수가 3로 나누어 떨어지는 경우
    if i % 3 == 0:
        d[i] = min(d[i], d[i//3]+1) 
    # 현재의 수가 2로 나누어 떨어지는 경우
    if i % 5 == 0:
        d[i] = min(d[i], d[i//5]+1)

print(d[x])

'''
2021.11.01
[이것이 코딩테스트다] p.220 개미 전사
개미 전사는 부족한 식량을 충당하고자 메뚜기 마을의 식량창고를 몰래 공격하려고 한다. 메뚜기 마을에는 여러 개의 식량창고가 있는데 식량창고는 일식선으로 이어져 있다. 각 식량창고에는 정해진 수의 식량을 저장하고 있으며 개미 전사는 식량창고를 선택적으로 약탈하여 식량을 빼앗을 예정이다. 이때 메뚜기 정찰병들은 일직선상에 존재하는 식량창고 중에서 서로 인접한 식량창고가 공격받으면 바로 알아챌 수 있다. 따라서 개미 전사가 정찰병에게 들키지 않고 식량창고를 약탈하기 위해서는 최소한 한 칸 이상 떨어진 식량창고를 약탈해야 한다. 예를 들어 식량창고 4개가 다음과 같이 존재한다고 하자

{1, 3, 1, 5}

개미전사는 두 번째 식량창고와 네 번째 식량창고를 선택했을 때 최댓값인 총 8개의 식량을 빼앗을 수 있다. 개미 전사를 식량창고가 이렇게 일진석상일 때 최대한 많은 식량을 얻어야 한다. 식량창고 N개에 대한 정보가 주어졌을 때 얻을 수 있는 식량의 최댓값을 구하는 프로그래밍을 작성하시오.
<입력예시> <출력 예시>
4
1 3 1 5  8
'''
# 나의 답
n = int(input())

d = [0] * 100

def pibo(x):
    if x == 1 or x == 2:
        return 1
    if d[x] != 0:
        return d[x]
    
# 해설
'''
왼쪽부터 차례대로 식량창고를 털지 안 털지를 결정하는 경우와 특정한 i번째 식량창고에 대해서 털지 안 털지의 여부를 결정할 때, 단 2가지 경우를 확인하면 된다
a. (i - 1)번째 식량창고를 털기로 결정한 경우 현재의 식량창고를 털 수 없다.
b. (i - 2)번째 식량창고를 털기로 결정한 경우 현재의 식량창고를 털 수 있다.
왼쪽부터 (i-3)번째 이하의 식량창고에 대해서는 고려할 필요가 없다. 왜냐하면 한 칸 이상 떨어진 식량창고는 항상 털 수 있기 때문이다. 
'''

# 정수 N을 입력받기
n = int(input())
array = list(map(int, input().split()))

d = [0] * 100

# 다이나믹 프로그래밍 진행(보텀업)
d[0] = array[0]
d[1] = max(array[0], array[1])
for i in range(2, n):
    d[i] = max(d[i-1], d[i-2]+array[i])

print(d[n-1])


