'''
2021.10.28
[이것이 코딩테스트다] p.217 1로 만들기
정수 X가 주어질 때 정수 X에 사용할 수 있는 연산은 다음과 같다
a. X가 5로 나누어떨어지면, 5로 나눈다.
b. X가 3로 나누어떨어지면, 3로 나눈다.
c. X가 2로 나누어떨어지면, 5로 나눈다.
d. X에서 1을 뺀다.
연산 4개를 적절히 이용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.
<입력예시> <출력 예시>
26       3
'''
# 나의 답
n = 26
r = 0

while True:
    if n == 0:
        break
    if n & 5 == 0:
        n = n // 5
        r += 1
        print('--1', n, r)
    elif n & 3 == 0:
        n = n // 3
        r += 1
        print('--2', n, r)
    elif n & 2 == 0:
        n = n // 2
        r += 1
        print('--3', n, r)
    else:
        n = n - 1
        r += 1
        print('--4', n, r)
        
print(r)

# 해설
x = int(input())

# 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화
d = [0] * 30001

# 다이나믹 프로그래밍 진행(보텀업)
for i in range(2,  x+1):
    # 현재의 수에서 1을빼는 경우
    d[i] = d[i - 1] + 1
    # 현재의 수가 2로 나누어 떨어지는 경우
    if i % 2 == 0:
        d[i] = min(d[i], d[i//2]+1)
    # 현재의 수가 3로 나누어 떨어지는 경우
    if i % 3 == 0:
        d[i] = min(d[i], d[i//3]+1) 
    # 현재의 수가 2로 나누어 떨어지는 경우
    if i % 5 == 0:
        d[i] = min(d[i], d[i//5]+1)

print(d[x])

'''
2021.11.01
[이것이 코딩테스트다] p.220 개미 전사
개미 전사는 부족한 식량을 충당하고자 메뚜기 마을의 식량창고를 몰래 공격하려고 한다. 메뚜기 마을에는 여러 개의 식량창고가 있는데 식량창고는 일식선으로 이어져 있다. 각 식량창고에는 정해진 수의 식량을 저장하고 있으며 개미 전사는 식량창고를 선택적으로 약탈하여 식량을 빼앗을 예정이다. 이때 메뚜기 정찰병들은 일직선상에 존재하는 식량창고 중에서 서로 인접한 식량창고가 공격받으면 바로 알아챌 수 있다. 따라서 개미 전사가 정찰병에게 들키지 않고 식량창고를 약탈하기 위해서는 최소한 한 칸 이상 떨어진 식량창고를 약탈해야 한다. 예를 들어 식량창고 4개가 다음과 같이 존재한다고 하자

{1, 3, 1, 5}

개미전사는 두 번째 식량창고와 네 번째 식량창고를 선택했을 때 최댓값인 총 8개의 식량을 빼앗을 수 있다. 개미 전사를 식량창고가 이렇게 일진석상일 때 최대한 많은 식량을 얻어야 한다. 식량창고 N개에 대한 정보가 주어졌을 때 얻을 수 있는 식량의 최댓값을 구하는 프로그래밍을 작성하시오.
<입력예시> <출력 예시>
4
1 3 1 5  8
'''
# 나의 답
n = int(input())

d = [0] * 100

def pibo(x):
    if x == 1 or x == 2:
        return 1
    if d[x] != 0:
        return d[x]
    
# 해설
'''
왼쪽부터 차례대로 식량창고를 털지 안 털지를 결정하는 경우와 특정한 i번째 식량창고에 대해서 털지 안 털지의 여부를 결정할 때, 단 2가지 경우를 확인하면 된다
a. (i - 1)번째 식량창고를 털기로 결정한 경우 현재의 식량창고를 털 수 없다.
b. (i - 2)번째 식량창고를 털기로 결정한 경우 현재의 식량창고를 털 수 있다.
왼쪽부터 (i-3)번째 이하의 식량창고에 대해서는 고려할 필요가 없다. 왜냐하면 한 칸 이상 떨어진 식량창고는 항상 털 수 있기 때문이다. 
'''

# 정수 N을 입력받기
n = int(input())
array = list(map(int, input().split()))

d = [0] * 100

# 다이나믹 프로그래밍 진행(보텀업)
d[0] = array[0]
d[1] = max(array[0], array[1])
for i in range(2, n):
    d[i] = max(d[i-1], d[i-2]+array[i])

print(d[n-1])


'''
2021.11.03
[이것이 코딩테스트다] p.223 바닥공사
가로의 길이가 N, 세로의 길이가 2인 정사각형 형태의 얇은 바닥이 있다. 태일이는 이 얇은 바닥을 1 * 2의 덮개, 2 * 1의 덮개, 2 * 2의 덮개를 이용해 채우고자 한다. 
이때 바닥을 채우는 모든 경우의 수를 구하는 프로그램을 작성한다. 예를 들어 2 * 3의 크기의 바닥을 채우는 경우의 수는 5가지 이다.
<입력예시> <출력 예시>
3        5
'''
# 나의 답(못 품..)
n = int(input())
d = [0] * 1001
# 해설
'''
다이나믹 프로그래밍의 기초 예제에서 빠질 수 없는 타일링 문제 유형이다. 다이나믹 프로그래밍 문제에서는 종종 결과를 어떤 수로 나눈 결과를 출력하라는 내용이 들어가있는 경우가 많다. 이 문제에서도 796,796으로 나눈 나머지를 출력하라고 하는데, 이는 단지 결과값이 굉장히 커질 수 있기 때문에 그런 것이다. 따라서 값을 계산할 땜다ㅏ 특정한 수로 나눈 나머지만 취하도록 하면 된다.

왼쪽부터 차례대로 바닥을 덮개로 채운다고 생각하면 어렵지 않게 점화식을 세울 수 있다.
1. 왼쪽부터 i-1까지 길이가 덮개로 이미 채워져 있으면 2 * 1의 덮개를 채우는 하나의 경우밖에 존재하지 않는다.
2. 왼쪽부터 i-1까지 길이가 덮개로 이미 채워져 있으면 1 * 2 덮개 2개를 넣는 경우, 혹은 2 * 2의 덮개 하나를 넣는 경우로 2가지 경우가 존재한다.
또한 이 문제 역시 왼쪽부터 N-2 미만의 길이에 대해서는 고려할 필요가 없다. 왜냐하면 사용할 수 있는 덮개의 형태가 최대 2 * 2의 직사각형 형태이기 때문이다. 다시 말해 바닥을 채울 수 있는 형태는 위에서 언급한 경우밖에 없다. ㄸ
'''
n = int(input())
d = [0] * 1001

# 다이나믹 프로그래밍 진행(보텀업)
d[1] = 1
d[2] = 3
for i in range(3, n+1):
    d[i] = (d[i-1]+2 * d[i-2]) % 796796

print(d[n])