'''
[이것이 코딩테스트다] p.92 큰 수의 법칙

순서대로 2, 4, 5, 2, 6으로 이루어진 배열이 있을 때 M이 8이고, K가 3이라고 가정하자. 
이 경우 특정한 인덱스의 수가 연속해서 세 번까지만 더해질 수 있으므로 큰 수의 법칙에 따른 결과는는 6+6+6+5+6+6+6+5인 46이 된다.

단, 서로 다른 인덱스에 해당하는 수가 같은 경우에도 서로 다른 것으로 간주한다. 예를 들어 순서대로 3, 4, 3, 4, 3으로 이루어진 
배열이 있을 때 m이 7이고, K가 2라고 하정하자. 이 경우 두 번째 원소에 해당하는 4와 네번째 원소에 해당하는 4를 번갈아 두 번씩 더하는 것이 가능하다. 4+4+4+4+4+4+4인 28이 도출
'''

# 나의 답
n, m, k = map(int, input().split())
data=list(map(int, input().split()))
data.sort(reverse=True)

print('---')
print(data)

count=0
aa=[]
for i in range(m):
    if count<k:
        aa.append(data[0])
        count+=1
    else:
        aa.append(data[1])
        count=0

    print(aa, count)

print(sum(aa))

# 해설
'''
이 문제는 M이 10000 이하이므로 내 방식처럼 풀 수 있지만, M의 크기가 100억 이상처럼 커진다면 시간 초과 판정을 받을 수 있다.

이 문제를 풀려면 가장 먼저 반복되는 수열에 대해 파악해야 한다. 가장 큰 수와 두 번째로 큰 수가 더해질 때는 특정한 수열 형태로 일정하게 반복해서 더해지는 특성이 있다. 위의 예시에서는 수열 {6,6,6,5}가 반복된다. 그렇다면 반복되는 수열의 길이는 어떻게 될까? 
바로 (K+1)로 위의 예시에서는 4가 된다. 따라서 M을 (K+1)로 나눈 몫이 수열이 반복되는 횟수가 된다. 다시 여기에 K를 곱해주면 가장 큰 수가 등장하는 횟수가 된다.
 이때 M이 (K+1)로 나누어떨이지지 않는 경우도 고려해야 한다. 그럴 때는 M을 (K+1)로 나눈 나머지만큼 가장 큰 수가 추가로 더해지므로 이를 고려해주어야 한다. 즉 '가장 큰 수가 더해지는 횟수'는 다음과 같다.

    int(M / (K+1)) * K + M % (K+1)

결과적으로 위의 식을 이용하여 가장 큰 수가 더해지는 횟수를 구한 다음, 이를 이용해 두 번째로 큰 수가 더해지는 횟수까지 구할 수 있는 것이다.
'''

n, m, k = map(int, input().split())
data = list(map(int, input().split()))

data.sort()
first=data[n-1] # 가장 큰 수
second=data[n-2] # 두 번째로 큰 수

# 가장 큰 수가 더해지는 횟수 계산
count = int(m/(k+1))*k
count += m % (k+1)

result=0
result += (count)*first # 가장 큰 수 더하기
result += (m-count) * second # 두 번째로 큰 수 더하기

print(result)


'''
[이것이 코딩테스트다] p.96 숫자 카드 게임

여러 개의 숫자 카드 중에서 가장 높은 숫자가 쓰인 카드 한 장을 뽑는 게임이다.
1. 숫자가 쓰인 카드들이 N * M 형태로 놓여있다. 이때 N은 행의 개수를 의미하며, M은 열의 개수를 의미한다.
2. 먼저 뽑고자 하는 카드가 포함되어 있는 행을 선택한다.
3. 그다음 선택된 행에 포함된 카드들 중 가장 숫자가 낮은 카드를 뽑아야 한다.
4. 따라서 처음에 카드를 골라낼 행을 선택할 때, 이후에 해당 행에서 가장 숫자가 낮은 카드를 뽑을 것을 고려하여 최종적으로 가장 높은 숫자의 카드를 뽑을 수 있도록 전략을 세워야 한다.

<입력예시 1> <출력 예시 1>
3 3         2
3 1 2
4 1 2
2 2 2

여기서 카드를 골라낼 행을 고를 때 첫 번째 혹인 두 번째 행을 선택하는 경우, 최종적으로 뽑는 카드는 1이다. 하지만 세 번째 행을 선택하는 경우 최종적으로 뽑는 카드는 2이다. 따라서 이 예제에서는 세 번째 행을 선택하여 숫자 2가 쓰여진 카드를 뽑는 것이 정답니다.

<입력예시 2> <출력 예시 2>
2 4         3
7 3 1 8
3 3 3 4
'''
#나의 답
n, m = map(int, input().split())
item=0
result=0
for i in range(n):
    data=list(map(int, input().split()))
    min_input=min(data)
    globals()['row{}'.format(i)] = data
    globals()['min_row{}'.format(i)] = min_input
    
    if i>0:
        if item<min_input: 
            item=min_input
            result=data[0]
    else:
        item=min_input
    print(item)
    
print('---result---')
print(result)

#해설
'''
각 행마다 가장 작은 수를 찾은 뒤에 그 수 중에서 가장 큰 수를 찾는 문제이다.

* 내가 문제를 잘못 이해했다. 각 행 중에 가장 작은 수를 찾고 극 중에 가장 큰 수를 찾는 문제인데 나는 여기서 가장 큰 수의 첫번째 값을 찾았다. 내가 잘못 이해했지만 정말 우연히 입력 예시가 다 맞아떨어짐.. 
'''
n, m = map(int, input().split())

result=0
for i in range(n):
    data=list(map(int, input().split()))
    # 현재 줄에서 '가장 작은 수' 찾기
    min_value=min(data)
    # '가장 작은 수'들 중에서 가장 큰 수 찾기
    result=max(result, min_value)

print(result)  